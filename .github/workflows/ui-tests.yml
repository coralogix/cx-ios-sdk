name: UI Tests

permissions:
  contents: read

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  ui-tests:
    name: Run DemoApp UI Tests
    runs-on: macos-14
    timeout-minutes: 30
    permissions:
      contents: read
      actions: read
      checks: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Select Xcode (via DEVELOPER_DIR)
        run: |
          if [ -d "/Applications/Xcode_16.2.app" ]; then
            echo "DEVELOPER_DIR=/Applications/Xcode_16.2.app/Contents/Developer" >> $GITHUB_ENV
          elif [ -d "/Applications/Xcode_16.1.app" ]; then
            echo "DEVELOPER_DIR=/Applications/Xcode_16.1.app/Contents/Developer" >> $GITHUB_ENV
          elif [ -d "/Applications/Xcode_16.0.app" ]; then
            echo "DEVELOPER_DIR=/Applications/Xcode_16.0.app/Contents/Developer" >> $GITHUB_ENV
          else
            echo "No pinned Xcode found; using default Xcode"
          fi

      - name: Make root use the same Xcode
        run: |
          set -euo pipefail
          if [ -n "${DEVELOPER_DIR:-}" ]; then
            echo "Switching root xcode-select to: $DEVELOPER_DIR"
            sudo xcode-select -s "$DEVELOPER_DIR"
          else
            echo "DEVELOPER_DIR not set; using system default Xcode"
          fi
          sudo xcodebuild -version
          sudo xcodebuild -license accept || true

      - name: Show Xcode version
        run: |
          echo "Using DEVELOPER_DIR=${DEVELOPER_DIR:-"(not set)"}"
          xcodebuild -version

      - name: Xcode first launch setup
        run: |
          sudo env DEVELOPER_DIR="${DEVELOPER_DIR:-}" xcodebuild -runFirstLaunch || sudo xcodebuild -runFirstLaunch

      - name: üîé Xcode & Simulator Diagnostics
        run: |
          echo "===== XCODE SELECT ====="
          xcode-select -p
          echo

          echo "===== XCODE VERSION ====="
          xcodebuild -version
          echo

          echo "===== INSTALLED SDKs ====="
          xcodebuild -showsdks || true
          echo

          echo "===== INSTALLED SIMULATOR RUNTIMES ====="
          xcrun simctl list runtimes || true
          echo

      - name: Verify iOS Simulator SDK exists (fail fast)
        run: |
          set -euo pipefail
          if ! xcodebuild -showsdks | grep -q "iOS Simulator"; then
            echo "‚ùå iOS Simulator SDK is missing in this Xcode. Can't run UI tests on this runner."
            exit 1
          fi
          echo "‚úÖ iOS Simulator SDK is present."

      - name: Verify project structure
        run: |
          echo "üìã Verifying project structure..."
          if [ -f "Example/DemoApp.xcworkspace/contents.xcworkspacedata" ]; then
            echo "‚úÖ Found workspace: Example/DemoApp.xcworkspace"
          elif [ -d "Example/DemoApp.xcodeproj" ]; then
            echo "‚úÖ Found project: Example/DemoApp.xcodeproj"
          else
            echo "‚ùå Project/workspace not found in Example/ directory"
            find . -name "*.xcworkspace" -o -name "*.xcodeproj" | head -10
            exit 1
          fi

      - name: List available schemes
        run: |
          cd Example
          if [ -f "DemoApp.xcworkspace/contents.xcworkspacedata" ]; then
            xcodebuild -list -workspace DemoApp.xcworkspace
          else
            xcodebuild -list -project DemoApp.xcodeproj
          fi

      - name: List available iOS simulators
        run: |
          set -euo pipefail
          echo "üì± Available iOS Simulators:"
          xcrun simctl list devices available | grep -E "iPhone|iPad" | head -20 || true
          echo ""
          echo "üì± iOS 18.5+ Simulators:"
          xcrun simctl list devices available | grep -E "iPhone|iPad" | grep -E "18\.[5-9]|19\." || echo "No iOS 18.5+ simulators found"

      - name: Set build configuration
        run: |
          if [ -f "Example/DemoApp.xcworkspace/contents.xcworkspacedata" ]; then
            echo "BUILD_TYPE=-workspace" >> $GITHUB_ENV
            echo "BUILD_PATH_RELATIVE=DemoApp.xcworkspace" >> $GITHUB_ENV
          elif [ -d "Example/DemoApp.xcodeproj" ]; then
            echo "BUILD_TYPE=-project" >> $GITHUB_ENV
            echo "BUILD_PATH_RELATIVE=DemoApp.xcodeproj" >> $GITHUB_ENV
          else
            echo "‚ùå No Xcode workspace or project found in Example/ directory!"
            exit 1
          fi
          echo "SCHEME=DemoAppSwift" >> $GITHUB_ENV

      - name: Install xcpretty (optional)
        run: |
          if ! command -v xcpretty &> /dev/null; then
            gem install xcpretty || true
          fi

      - name: Install Fastlane
        run: |
          if ! command -v fastlane &> /dev/null; then
            gem install fastlane || true
          fi
          fastlane --version

      - name: Set destination (auto from xcodebuild)
        run: |
          set -euo pipefail
          cd Example

          OUT=$(xcodebuild -showdestinations -workspace DemoApp.xcworkspace -scheme DemoAppSwift)
          echo "$OUT"

          # Prefer iPhone 16 or newer with iOS 18.0+ (we override deployment target in CI)
          LINE=$(echo "$OUT" | grep -E "platform:iOS Simulator, id:.*name:iPhone (1[6-9]|[2-9][0-9])" | grep -E "OS:1[89]\.[0-9]" | head -1 || true)
          
          # If not found, try any iPhone with iOS 18.0+
          if [ -z "$LINE" ]; then
            LINE=$(echo "$OUT" | grep -E "platform:iOS Simulator, id:.*name:iPhone" | grep -E "OS:1[89]\.[0-9]" | head -1 || true)
          fi
          
          # If still not found, try any iPhone with iOS 17.0+ (fallback)
          if [ -z "$LINE" ]; then
            LINE=$(echo "$OUT" | grep -E "platform:iOS Simulator, id:.*name:iPhone" | grep -E "OS:1[7-9]\.[0-9]" | head -1 || true)
          fi
          
          # Last resort: any iPhone simulator
          if [ -z "$LINE" ]; then
            LINE=$(echo "$OUT" | grep -E "platform:iOS Simulator, id:.*name:iPhone" | head -1 || true)
          fi
          
          if [ -z "$LINE" ]; then
            echo "‚ùå No iPhone simulator destination found"
            exit 1
          fi

          NAME=$(echo "$LINE" | sed -n 's/.*name:\([^,}]*\).*/\1/p' | xargs)
          OS=$(echo "$LINE" | sed -n 's/.*OS:\([^,}]*\).*/\1/p' | xargs)

          if [ -z "$NAME" ] || [ -z "$OS" ]; then
            echo "‚ùå Failed to parse destination from line: $LINE"
            exit 1
          fi

          echo "‚úÖ Selected simulator: $NAME ($OS) - deployment target will be overridden to 18.0 for CI"

          echo "DESTINATION_SPEC=platform=iOS Simulator,name=$NAME,OS=$OS" >> $GITHUB_ENV
          echo "SIMULATOR_NAME=$NAME" >> $GITHUB_ENV
          echo "üéØ Final destination spec: platform=iOS Simulator,name=$NAME,OS=$OS"

      - name: Boot simulator (ensure ready)
        run: |
          set -euo pipefail
          echo "üì± Ensuring simulator is booted and ready..."
          
          # Use the simulator name from destination selection
          if [ -n "${SIMULATOR_NAME:-}" ]; then
            echo "   Attempting to boot: $SIMULATOR_NAME"
            xcrun simctl boot "$SIMULATOR_NAME" 2>/dev/null || echo "   Simulator already booted or booting..."
          else
            # Fallback: try common device names
            echo "   Attempting to boot iPhone 16..."
            xcrun simctl boot "iPhone 16" 2>/dev/null || \
            xcrun simctl boot "iPhone 15" 2>/dev/null || echo "   Could not boot simulator by name"
          fi
          
          # Wait for simulator to be fully booted (reduced from 5s + 3s)
          echo "   Waiting for simulator to be ready..."
          sleep 3
          
          # Verify simulator is booted
          BOOTED=$(xcrun simctl list devices booted | grep -i "iPhone" | head -1 || echo "")
          if [ -z "$BOOTED" ]; then
            echo "   ‚ö†Ô∏è No booted iPhone simulator found, but continuing..."
          else
            echo "   ‚úÖ Booted simulator: $BOOTED"
          fi
          
          xcrun simctl list devices booted || true

      - name: Generate envs.swift (CI)
        run: |
          set -euo pipefail
          cd Example
          PUBLIC_KEY="${{ secrets.DEMOAPP_API_KEY || 'CI_DUMMY' }}"
          printf 'import Foundation\n\npublic enum Envs: String {\n    case PUBLIC_KEY = "%s"\n    case PROXY_URL = "https://schema-validator-latest.onrender.com/logs"\n}\n' "$PUBLIC_KEY" > envs.swift

          echo "‚úÖ Generated envs.swift"
          ls -la envs.swift
          cat envs.swift

      - name: Create placeholder GoogleService-Info.plist (CI)
        run: |
          set -euo pipefail
          cd Example
          # Create a minimal valid plist file to satisfy the build requirement
          # The app will detect it's missing and skip Firebase initialization
          # Alternative: Store a real test Firebase project plist as a secret and use:
          # echo "${{ secrets.FIREBASE_TEST_PLIST }}" > GoogleService-Info.plist
          printf '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n  <key>CLIENT_ID</key>\n  <string>CI_DUMMY_CLIENT_ID</string>\n  <key>REVERSED_CLIENT_ID</key>\n  <string>CI_DUMMY_REVERSED_CLIENT_ID</string>\n  <key>API_KEY</key>\n  <string>CI_DUMMY_API_KEY</string>\n  <key>GCM_SENDER_ID</key>\n  <string>123456789</string>\n  <key>PLIST_VERSION</key>\n  <string>1</string>\n  <key>BUNDLE_ID</key>\n  <string>com.coralogix.DemoAppSwift</string>\n  <key>PROJECT_ID</key>\n  <string>ci-dummy-project</string>\n  <key>STORAGE_BUCKET</key>\n  <string>ci-dummy-project.appspot.com</string>\n  <key>IS_ADS_ENABLED</key>\n  <false/>\n  <key>IS_ANALYTICS_ENABLED</key>\n  <false/>\n  <key>IS_APPINVITE_ENABLED</key>\n  <true/>\n  <key>IS_GCM_ENABLED</key>\n  <true/>\n  <key>IS_SIGNIN_ENABLED</key>\n  <true/>\n  <key>GOOGLE_APP_ID</key>\n  <string>1:123456789:ios:abcdef123456</string>\n</dict>\n</plist>\n' > GoogleService-Info.plist
          echo "‚úÖ Created placeholder GoogleService-Info.plist (app will skip Firebase init)"
          ls -la GoogleService-Info.plist

      - name: Build for testing (with cache)
        uses: actions/cache@v4
        id: xcode-cache
        with:
          path: |
            ~/Library/Developer/Xcode/DerivedData
          key: xcode-${{ runner.os }}-${{ hashFiles('**/Podfile.lock', '**/Package.resolved', '**/*.xcodeproj/project.pbxproj', '**/*.xcworkspace/contents.xcworkspacedata') }}
          restore-keys: |
            xcode-${{ runner.os }}-
            xcode-

      - name: Build for testing
        run: |
          set -euo pipefail
          cd Example

          CI_DEPLOYMENT_TARGET="18.0"
          echo "üî® Building for testing..."
          BUILD_START=$(date +%s)

          if command -v xcpretty &> /dev/null; then
            xcodebuild build-for-testing \
              $BUILD_TYPE "$BUILD_PATH_RELATIVE" \
              -scheme "$SCHEME" \
              -destination "$DESTINATION_SPEC" \
              -derivedDataPath ../DerivedData \
              CODE_SIGNING_ALLOWED=NO \
              CODE_SIGN_IDENTITY="" \
              IPHONEOS_DEPLOYMENT_TARGET="$CI_DEPLOYMENT_TARGET" \
              -jobs $(sysctl -n hw.ncpu) \
              | xcpretty --color || cat
          else
            xcodebuild build-for-testing \
              $BUILD_TYPE "$BUILD_PATH_RELATIVE" \
              -scheme "$SCHEME" \
              -destination "$DESTINATION_SPEC" \
              -derivedDataPath ../DerivedData \
              CODE_SIGNING_ALLOWED=NO \
              CODE_SIGN_IDENTITY="" \
              IPHONEOS_DEPLOYMENT_TARGET="$CI_DEPLOYMENT_TARGET" \
              -jobs $(sysctl -n hw.ncpu)
          fi

          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          echo "‚úÖ Build completed in ${BUILD_DURATION}s ($(($BUILD_DURATION / 60))m $(($BUILD_DURATION % 60))s)"

      - name: Run UI Tests
        run: |
          set -euo pipefail

          CI_DEPLOYMENT_TARGET="18.0"
          echo "üß™ Running UI tests via Fastlane (deployment target: $CI_DEPLOYMENT_TARGET)"
          echo "‚è±Ô∏è  Start time: $(date)"

          set +e
          TEST_START=$(date +%s)
          
          # Run Fastlane UI tests lane from root (Fastfile is in fastlane/ directory)
          # Pass workspace path relative to root
          fastlane ui_tests \
            workspace:"Example/$BUILD_PATH_RELATIVE" \
            scheme:"$SCHEME" \
            destination:"$DESTINATION_SPEC" \
            derived_data_path:"DerivedData" \
            test_class:"DemoAppUITests/SanityUITests/testAppSanity_mainViewAppearsOnLaunch" \
            deployment_target:"$CI_DEPLOYMENT_TARGET" \
            skip_build:true \
            working_directory:"Example"
          EXIT_CODE=$?
          
          TEST_END=$(date +%s)
          TEST_DURATION=$((TEST_END - TEST_START))
          echo "‚è±Ô∏è  Test duration: ${TEST_DURATION}s ($(($TEST_DURATION / 60))m $(($TEST_DURATION % 60))s)"

          if [ "$EXIT_CODE" -ne 0 ]; then
            echo ""
            echo "==================== ‚ùå TEST FAILURE DETAILS ===================="
            echo "Exit code: $EXIT_CODE"
            echo ""
            
            # Extract test logs (print statements from test)
            if [ -f test-output.log ]; then
              echo "üìã Test Logs (print statements from test):"
              grep -E "üïê|üì±|üîç|‚úÖ|‚ùå|üëÜ|‚è≥|üìÑ|üöÄ" test-output.log | tail -50 || echo "   No test logs found"
              echo ""
              
              echo "üîé Last 150 lines of test output:"
              tail -n 150 test-output.log
              echo ""
              
              echo "üîé Key error patterns:"
              grep -iE "error|fail|timeout|assert|unable|not found|did not appear" test-output.log | tail -30 || echo "   No error patterns found"
            fi
            
            # Extract assertion failures from log
            if [ -f test-output.log ]; then
              echo ""
              echo "üîç Searching for assertion failures in test output log..."
              
              # Look for XCTest assertion messages (they often appear in the log)
              ASSERTION_FAILURES=$(grep -iE "XCTAssert|assertion failed|button not found|not found|did not appear|failed.*assertion" test-output.log 2>/dev/null | head -10 || echo "")
              if [ -n "$ASSERTION_FAILURES" ]; then
                echo "   Found assertion-related messages:"
                echo "$ASSERTION_FAILURES" | sed 's/^/   /'
              fi
              
              # Also look for the actual test print statements (from the test code)
              TEST_LOGS=$(grep -E "üïê|üîé|‚úÖ|‚ùå" test-output.log 2>/dev/null | tail -20 || echo "")
              if [ -n "$TEST_LOGS" ]; then
                echo ""
                echo "   Test execution logs:"
                echo "$TEST_LOGS" | sed 's/^/   /'
              fi
              
              # Look for specific error patterns that might indicate the failure
              ERROR_PATTERNS=$(grep -iE "Network instrumentation|button.*not found|element.*not found|waitForExistence.*timeout" test-output.log 2>/dev/null | head -5 || echo "")
              if [ -n "$ERROR_PATTERNS" ]; then
                echo ""
                echo "   Potential error indicators:"
                echo "$ERROR_PATTERNS" | sed 's/^/   /'
              fi
            fi
            
            # Extract from xcresult if available
            if [ -d DerivedData/TestResults.xcresult ]; then
              echo ""
              echo "üì¶ Extracting test failure details from xcresult bundle..."
              
              # First, try to get a summary using xcresulttool (more reliable)
              SUMMARY_OUTPUT=$(xcrun xcresulttool get --format json --path DerivedData/TestResults.xcresult 2>/dev/null | jq -r '.actions._values[0].actionResult.testsRef.id._value // .actions._values[0].actionResult.testsRef.id.value // empty' 2>/dev/null || echo "")
              
              TEMP_JSON=$(mktemp)
              EXTRACTED_ERROR=false
              
              # Try legacy API first (required in newer Xcode versions)
              if xcrun xcresulttool get object --legacy --path DerivedData/TestResults.xcresult --format json > "$TEMP_JSON" 2>/dev/null || \
                 xcrun xcresulttool get --format json --path DerivedData/TestResults.xcresult > "$TEMP_JSON" 2>/dev/null; then
                if [ -s "$TEMP_JSON" ]; then
                  # Try to extract failure details using jq with multiple fallback strategies
                  if command -v jq &> /dev/null; then
                    # Strategy 1: Look for testFailureSummaries in the standard location
                    # Extract ALL failures with proper message parsing
                    JQ_QUERY1='.. | select(.testFailureSummaries? != null) | .testFailureSummaries[]? | select(.message != null or .messageText != null) | {
                      msg: (if .messageText != null then (if .messageText | type == "object" then (.messageText._value // .messageText.value // .messageText | tostring) else (.messageText | tostring) end) elif .message != null then (if .message | type == "object" then (.message._value // .message.value // .message | tostring) else (.message | tostring) end) else "Unknown error" end),
                      file: (if .fileName | type == "object" then (.fileName._value // .fileName.value // "Unknown" | tostring) else (.fileName // "Unknown" | tostring) end),
                      line: (if .lineNumber | type == "object" then (.lineNumber._value // .lineNumber.value // "?" | tostring) else (.lineNumber // "?" | tostring) end)
                    } | "‚ùå " + .msg + "\nüìÑ " + .file + ":" + .line'
                    JQ_OUTPUT=$(jq -r "$JQ_QUERY1" "$TEMP_JSON" 2>/dev/null || echo "")
                    
                    # Clean up the message - remove "XCTAssertTrue failed - " prefix if present
                    if [ -n "$JQ_OUTPUT" ] && [ "$JQ_OUTPUT" != "null" ] && [ "$JQ_OUTPUT" != "" ]; then
                      # Remove the "XCTAssertTrue failed - " prefix to show just the actual error message
                      CLEANED_OUTPUT=$(echo "$JQ_OUTPUT" | sed 's/XCTAssertTrue failed - //g' | sed 's/XCTAssert.*failed - //g')
                      FAILURE_COUNT=$(echo "$CLEANED_OUTPUT" | grep -c "‚ùå" || echo "0")
                      if [ "$FAILURE_COUNT" -gt 1 ]; then
                        echo "   Found $FAILURE_COUNT failure(s):"
                      fi
                      JQ_OUTPUT="$CLEANED_OUTPUT"
                    fi
                    
                    # Strategy 2: If Strategy 1 didn't work, try looking for issues.testFailureSummaries
                    if [ -z "$JQ_OUTPUT" ] || [ "$JQ_OUTPUT" = "null" ]; then
                      JQ_QUERY2='.issues[]? | select(.testFailureSummaries != null) | .testFailureSummaries[]? | select(.message != null) | "‚ùå " + (if .message | type == "object" then (.message._value // .message.value // .message | tostring) else (.message | tostring) end) + "\nüìÑ " + (if .fileName | type == "object" then (.fileName._value // .fileName.value // "Unknown" | tostring) else (.fileName // "Unknown" | tostring) end) + ":" + (if .lineNumber | type == "object" then (.lineNumber._value // .lineNumber.value // "?" | tostring) else (.lineNumber // "?" | tostring) end)'
                      JQ_OUTPUT=$(jq -r "$JQ_QUERY2" "$TEMP_JSON" 2>/dev/null || echo "")
                    fi
                    
                    # Strategy 3: Look for any failure message in the structure
                    if [ -z "$JQ_OUTPUT" ] || [ "$JQ_OUTPUT" = "null" ]; then
                      JQ_QUERY3='.. | select(type == "object" and (.message != null or .failureMessage != null)) | "‚ùå " + (if .message != null then (if .message | type == "object" then (.message._value // .message.value // .message | tostring) else (.message | tostring) end) elif .failureMessage != null then (if .failureMessage | type == "object" then (.failureMessage._value // .failureMessage.value // .failureMessage | tostring) else (.failureMessage | tostring) end) else "Unknown error" end) + "\nüìÑ " + (if .fileName != null then (if .fileName | type == "object" then (.fileName._value // .fileName.value // "Unknown" | tostring) else (.fileName | tostring) end) else "Unknown" end) + ":" + (if .lineNumber != null then (if .lineNumber | type == "object" then (.lineNumber._value // .lineNumber.value // "?" | tostring) else (.lineNumber | tostring) end) else "?" end)'
                      JQ_OUTPUT=$(jq -r "$JQ_QUERY3" "$TEMP_JSON" 2>/dev/null | head -3 || echo "")
                    fi
                    
                    # Check if we got output but it's just "Unknown error" - try to get more details
                    if [ -n "$JQ_OUTPUT" ] && [ "$JQ_OUTPUT" != "null" ] && [ "$JQ_OUTPUT" != "" ]; then
                      # If the message is "Unknown error", try to extract the raw structure
                      if echo "$JQ_OUTPUT" | grep -q "Unknown error"; then
                        echo "   ‚ö†Ô∏è  Found failure but message field is empty/null"
                        echo "   üîç Attempting to extract raw failure structure..."
                        RAW_FAILURE=$(jq '.. | select(.testFailureSummaries? != null) | .testFailureSummaries[0]' "$TEMP_JSON" 2>/dev/null || echo "")
                        if [ -n "$RAW_FAILURE" ] && [ "$RAW_FAILURE" != "null" ]; then
                          echo "      Raw failure structure:"
                          echo "$RAW_FAILURE" | jq '.' 2>/dev/null | head -40 | sed 's/^/      /' || echo "$RAW_FAILURE" | head -40 | sed 's/^/      /'
                        fi
                        # Still show what we found
                        echo ""
                        echo "   Extracted (message may be incomplete):"
                        echo "$JQ_OUTPUT" | sed 's/^/   /'
                        EXTRACTED_ERROR=true
                      else
                        echo "   ‚úÖ Extracted failure details:"
                        echo "$JQ_OUTPUT" | sed 's/^/   /'
                        EXTRACTED_ERROR=true
                      fi
                    else
                      # Debug: Try to find what's actually in the JSON
                      echo "   üîç Debug: Inspecting xcresult structure..."
                      # Check if we can find testFailureSummaries at all
                      HAS_SUMMARIES=$(jq '.. | select(.testFailureSummaries? != null) | .testFailureSummaries | length' "$TEMP_JSON" 2>/dev/null | head -1 || echo "0")
                      if [ "$HAS_SUMMARIES" != "0" ] && [ "$HAS_SUMMARIES" != "null" ]; then
                        echo "      Found $HAS_SUMMARIES test failure summary(ies)"
                        # Try to extract raw structure to see what fields are available
                        jq '.. | select(.testFailureSummaries? != null) | .testFailureSummaries[0] | keys' "$TEMP_JSON" 2>/dev/null | sed 's/^/      /' || echo "      (Could not extract structure)"
                        # Show the actual failure object
                        echo "      Failure object:"
                        jq '.. | select(.testFailureSummaries? != null) | .testFailureSummaries[0]' "$TEMP_JSON" 2>/dev/null | head -50 | sed 's/^/      /' || echo "      (Could not extract)"
                      else
                        echo "      No testFailureSummaries found in expected location"
                        echo "      Top-level keys:"
                        jq 'keys' "$TEMP_JSON" 2>/dev/null | head -10 | sed 's/^/      /' || echo "      (Could not inspect)"
                      fi
                    fi
                  fi
                fi
              fi
              
              if [ "$EXTRACTED_ERROR" = false ]; then
                echo "   ‚ö†Ô∏è  Could not extract detailed error from xcresult bundle"
                echo "   (The detailed assertion message is stored in the bundle but requires Xcode to view)"
                echo ""
                echo "   To view the full error details:"
                echo "   1. Download the xcresult bundle from the workflow artifacts"
                echo "   2. Open it in Xcode: open DerivedData/TestResults.xcresult"
                echo "   3. Or check the test code for the assertion message"
              fi
              
              rm -f "$TEMP_JSON"
            else
              echo ""
              echo "   ‚ö†Ô∏è  xcresult bundle not found at DerivedData/TestResults.xcresult"
            fi
            
            echo "============================================================="
            exit "$EXIT_CODE"
          fi
          
          echo "‚úÖ Tests passed!"
          echo "‚è±Ô∏è  End time: $(date)"

     